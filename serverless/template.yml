AWSTemplateFormatVersion: "2010-09-09"
Transform: AWS::Serverless-2016-10-31

Mappings:
  Constants:
    DatadogServerlessMacro:
      Version: 0.1.0

Parameters:
  FunctionName:
    Type: String
    Default: DatadogServerlessMacroLambda
    Description: The name of the Lambda function that is invoked when the macro is run.
  LogRetentionInDays:
    Type: Number
    Default: 90
    Description: CloudWatch log retention for logs generated by the Datadog Serverless Macro Lambda function
  SourceZipUrl:
    Type: String
    Default: ""
    Description: DO NOT CHANGE unless you know what you are doing. Override the default location of the function source code.
  PermissionsBoundaryArn:
    Type: String
    Default: ""
    Description: ARN for the Permissions Boundary Policy

Conditions:
  SetFunctionName:
    Fn::Not:
      - Fn::Equals:
          - Ref: FunctionName
          - "DatadogServerlessMacroLambda"
  SetSourceZipUrl:
    Fn::Not:
      - Fn::Equals:
          - Ref: SourceZipUrl
          - ""
  SetS3SourceZip:
    Fn::Equals:
      - !Select [0, !Split ["/", !Ref SourceZipUrl]]
      - "s3:"
  SetPermissionsBoundary:
    Fn::Not:
      - Fn::Equals:
          - Ref: PermissionsBoundaryArn
          - ""

Resources:
  MacroFunction:
    Type: AWS::Serverless::Function
    DependsOn: MacroFunctionZip
    Properties:
      FunctionName:
        Fn::If:
          - SetFunctionName
          - Ref: FunctionName
          - Ref: AWS::NoValue
      Description: Processes a CloudFormation template to install Datadog Lambda layers for Python and Node.js Lambda functions.
      Handler: index.handler
      Runtime: nodejs12.x
      CodeUri:
        Bucket: !Ref MacroFunctionZipsBucket
        Key:
          Fn::Sub:
            - "serverless-macro-${Version}.zip"
            - { Version: !FindInMap [Constants, DatadogServerlessMacro, Version] }
      Tags:
        dd_serverless_macro_version: !FindInMap [Constants, DatadogServerlessMacro, Version]
      PermissionsBoundary:
        Fn::If:
          - SetPermissionsBoundary
          - Ref: PermissionsBoundaryArn
          - Ref: AWS::NoValue
      Policies:
        - Version: "2012-10-17"
          Statement:
            - Effect: Allow
              Action:
                - logs:DescribeLogGroups
                - logs:CreateLogGroup
                - logs:DescribeSubscriptionFilters
                - logs:PutSubscriptionFilter
              Resource: "*"
  MacroFunctionLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName:
        Fn::Sub: /aws/lambda/${MacroFunction}
      RetentionInDays:
        Ref: LogRetentionInDays
  MacroFunctionZipsBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
  MacroFunctionZip:
    Type: Custom::MacroFunctionZip
    Properties:
      ServiceToken: !GetAtt "MacroFunctionZipCopier.Arn"
      DestZipsBucket: !Ref "MacroFunctionZipsBucket"
      SourceZipUrl:
        Fn::If:
          - SetSourceZipUrl
          - !Ref SourceZipUrl
          - Fn::Sub:
              - "https://github.com/DataDog/datadog-cloudformation-macro/releases/download/serverless-macro-${Version}/serverless-macro-${Version}.zip"
              - { Version: !FindInMap [Constants, DatadogServerlessMacro, Version] }
  MacroFunctionZipCopier:
    Type: AWS::Serverless::Function
    Properties:
      Description: Copies Datadog CloudFormation macro zip to the destination S3 bucket
      Handler: index.handler
      Runtime: python3.7
      Timeout: 300
      InlineCode: |
        import json
        import logging
        import threading
        import boto3
        import urllib.request
        import os
        def send_cfn_resp(event, context, response_status):
            resp_body = json.dumps({
                'Status': response_status,
                'Reason': f'See reasons in CloudWatch Logs - group: {context.log_group_name}, stream:{context.log_stream_name}',
                'PhysicalResourceId': context.log_stream_name,
                'StackId': event['StackId'],
                'RequestId': event['RequestId'],
                'LogicalResourceId': event['LogicalResourceId'],
                'Data': {}
            }).encode('utf-8')
            req = urllib.request.Request(url=event['ResponseURL'], data=resp_body, method='PUT')
            with urllib.request.urlopen(req) as f:
                logging.info(f'Sent response to CloudFormation: {f.status}, {f.reason}')
        def delete_zips(bucket):
            s3 = boto3.resource('s3')
            bucket = s3.Bucket(bucket)
            bucket.objects.all().delete()
        def copy_zip(source_zip_url, dest_zips_bucket):
            s3 = boto3.client('s3')
            s3_prelude = "s3://"
            filename = "serverless-macro-{}.zip".format(os.environ.get("DD_SERVERLESS_MACRO_VERSION"))
            if source_zip_url.startswith(s3_prelude):
                parts = source_zip_url[len(s3_prelude):].split('/')
                bucket = parts[0]
                key = '/'.join(parts[1:])
                response = s3.get_object(Bucket=bucket, Key=key)
                data = response["Body"]
                s3.upload_fileobj(data, dest_zips_bucket, filename)
            else:
                with urllib.request.urlopen(source_zip_url) as data:
                    s3.upload_fileobj(data, dest_zips_bucket, filename)
        def timeout(event, context):
            logging.error('Execution is about to time out, sending failure response to CloudFormation')
            send_cfn_resp(event, context, 'FAILED')
        def handler(event, context):
            # make sure we send a failure to CloudFormation if the function
            # is going to timeout
            timer = threading.Timer((context.get_remaining_time_in_millis()
                      / 1000.00) - 0.5, timeout, args=[event, context])
            timer.start()
            logging.info(f'Received event: {json.dumps(event)}')
            try:
                source_zip_url = event['ResourceProperties']['SourceZipUrl']
                dest_zips_bucket = event['ResourceProperties']['DestZipsBucket']
                if event['RequestType'] == 'Delete':
                    delete_zips(dest_zips_bucket)
                else:
                    copy_zip(source_zip_url, dest_zips_bucket)
            except Exception as e:
                logging.exception(f'Exception when copying zip from {source_zip_url} to {dest_zips_bucket}')
                send_cfn_resp(event, context, 'FAILED')
            else:
                send_cfn_resp(event, context, 'SUCCESS')
            finally:
                timer.cancel()
      Policies:
        - Version: "2012-10-17"
          Statement:
            - Effect: Allow
              Action:
                - s3:PutObject
                - s3:DeleteObject
              Resource:
                - Fn::Join:
                    - "/"
                    - - Fn::GetAtt: "MacroFunctionZipsBucket.Arn"
                      - "*"
            - Effect: Allow
              Action:
                - s3:ListBucket
              Resource:
                - Fn::GetAtt: "MacroFunctionZipsBucket.Arn"
            - !If
              - SetS3SourceZip
              - Effect: Allow
                Action:
                  - s3:GetObject
                Resource:
                  - Fn::Join:
                      - ""
                      - - "arn:*:s3:::"
                        - !Select [1, !Split ["s3://", !Ref SourceZipUrl]]
              - Ref: AWS::NoValue
      Environment:
        Variables:
          DD_SERVERLESS_MACRO_VERSION: !FindInMap [Constants, DatadogServerlessMacro, Version]
  Macro:
    Type: AWS::CloudFormation::Macro
    Properties:
      Name: DatadogServerless
      FunctionName: !GetAtt MacroFunction.Arn
